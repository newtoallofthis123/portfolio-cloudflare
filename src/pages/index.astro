---
import { siFramer, siGithub, siGo, siRust } from "simple-icons";
import Base from "../layouts/base.astro";
import Bold from "../spans/bold.astro";
import Link from "../spans/link.astro";
import { getCollection } from "astro:content";
import Char from "../spans/char.astro";
import Invideo from "../assets/invideo.svg";
import figlet from "figlet";
import slantFont from "figlet/fonts/Slant";
import doomFont from "figlet/fonts/Doom";
import bigFont from "figlet/fonts/Big";

figlet.parseFont("Slant", slantFont);
figlet.parseFont("Doom", doomFont);
figlet.parseFont("Big", bigFont);

const bannerTexts = ["Ishan Joshi", "Happy Holi"];
const bannerFonts = ["Slant", "Doom", "Big"] as const;

// asciiArts[fontIndex][textIndex]
const asciiArts: string[][] = bannerFonts.map((font) =>
  bannerTexts.map((text) => figlet.textSync(text, { font }))
);

let posts = await getCollection("blog");
posts = posts.filter((post) => !post.data.draft);
posts = posts.sort(
  (a: any, b: any) =>
    new Date(b.data.date).getTime() - new Date(a.data.date).getTime()
);
---

<Base>
  <h1 class="md:text-xl text-lg">
    Hi Internet Friend! I am <Bold>The Noob!</Bold>
  </h1>
  <div id="banner" class="my-2">
    <pre
      id="ascii-art"
      class="text-mx sm:text-base font-mono leading-tight"
      set:html={asciiArts[0][0]}
    />
  </div>
  <script
    is:inline
    id="ascii-data"
    type="application/json"
    set:html={JSON.stringify(asciiArts)}
  />
  <p>
    I am a ðŸŽ“ Student and an Engineer at <span id="inline-icon">
      <Invideo />
    </span> Invideo based in India.
  </p>
  <div class="mt-2">
    <p class="leading-7">
      A polyglot generalist who loves to learn and build, I've been dabbling in
      multiple languages and frameworks in my 4 years of programming. I love
      customizable and intuitive tools and love to build them <span
        id="inline-icon"
        set:html={siGithub.svg}
      />. CLI's are my favorite way to interact with computers, and I love
      building my own using <span id="inline-icon" set:html={siRust.svg} /> Rust.
      I've built up a speciality for <span
        id="inline-icon"
        set:html={siGo.svg}
      /> backend development, however I also built a quite some experience in frontend
      animations <span id="inline-icon" set:html={siFramer.svg} /> and design. Check
      out my blog to hear my rants and thoughts on pretty much everything.
    </p>
  </div>
  <div class="my-5 md:w-2/3 w-full">
    <h2 class="pb-3 md:text-2xl text-xl font-bold font-geist-mono">
      <Char /> show_blog_posts();
    </h2>
    <div>
      {
        posts.slice(0, 8).map((post) => (
          <div class="pb-2 flex flex-row items-baseline justify-between gap-x-4">
            <h2 class="underline decoration-0.5 decoration-dotted">
              <Link href={`/blog/${post.slug}`}>{post.data.title}</Link>
            </h2>
            <p class="text-rosePineDawn-subtle dark:text-rosePine-subtle">
              {new Date(post.data.date).toLocaleDateString()}
            </p>
          </div>
        ))
      }
    </div>
  </div>
</Base>
<style>
  ul {
    padding-top: 0.5rem;
    padding-left: 1.9rem;
    list-style: lower-alpha;
  }

  #ascii-art {
    white-space: pre;
    overflow-x: hidden;
  }
</style>
<script is:inline>
  document.addEventListener("DOMContentLoaded", () => {
    const el = document.getElementById("ascii-art");
    const dataEl = document.getElementById("ascii-data");
    if (!el || !dataEl) return;

    // asciiArts[fontIndex][textIndex]
    const asciiArts = JSON.parse(dataEl.textContent);

    const GLITCH_CHARS = "!@#$%^&*()_+-=[]{}|;:',.<>?/~`0123456789";
    const GLITCH_DURATION = 600;
    const FRAME_RATE = 50;
    const INITIAL_DELAY = 2000;

    function padLines(art) {
      const lines = art.split("\n");
      const maxWidth = Math.max(...lines.map((l) => l.length));
      return lines.map((l) => l.padEnd(maxWidth));
    }

    function morph(from, to, onComplete) {
      const fromLines = padLines(from);
      const toLines = padLines(to);

      const maxLines = Math.max(fromLines.length, toLines.length);
      const maxWidth = Math.max(
        fromLines[0]?.length || 0,
        toLines[0]?.length || 0
      );
      while (fromLines.length < maxLines) fromLines.push(" ".repeat(maxWidth));
      while (toLines.length < maxLines) toLines.push(" ".repeat(maxWidth));

      const fromGrid = fromLines.map((l) => l.padEnd(maxWidth));
      const toGrid = toLines.map((l) => l.padEnd(maxWidth));

      const totalFrames = Math.floor(GLITCH_DURATION / FRAME_RATE);
      let frame = 0;

      const interval = setInterval(() => {
        frame++;
        const progress = frame / totalFrames;

        const result = fromGrid.map((line, row) => {
          return Array.from(line)
            .map((char, col) => {
              const targetChar = toGrid[row]?.[col] ?? " ";
              const threshold =
                (Math.sin(row * 13.37 + col * 7.13) * 0.5 + 0.5) * 0.7 + 0.15;

              if (progress >= threshold) {
                return targetChar;
              } else if (progress > threshold * 0.3) {
                return GLITCH_CHARS[
                  Math.floor(Math.random() * GLITCH_CHARS.length)
                ];
              } else {
                return char;
              }
            })
            .join("");
        });

        el.textContent = result.join("\n");

        if (frame >= totalFrames) {
          clearInterval(interval);
          el.textContent = to;
          onComplete?.();
        }
      }, FRAME_RATE);
    }

    const PAUSE_INITIAL = 2000;
    const PAUSE_STEP = 1000;
    const PAUSE_MAX = 10000;

    // Pick a random font for this page load
    const fontIndex = Math.floor(Math.random() * asciiArts.length);
    const fontArts = asciiArts[fontIndex];

    let currentTextIndex = 0;
    let nextPause = PAUSE_INITIAL;
    let cycleTimer = null;
    let scrambleInterval = null;
    let isMorphing = false;

    el.textContent = fontArts[0];

    function scheduleCycle() {
      cycleTimer = setTimeout(cycle, nextPause);
      nextPause = Math.min(nextPause + PAUSE_STEP, PAUSE_MAX);
    }

    function cycle() {
      if (isMorphing) return;
      isMorphing = true;
      const nextTextIndex = (currentTextIndex + 1) % fontArts.length;
      morph(fontArts[currentTextIndex], fontArts[nextTextIndex], () => {
        currentTextIndex = nextTextIndex;
        isMorphing = false;
        scheduleCycle();
      });
    }

    // Hover scramble: continuously randomise characters while hovering
    el.addEventListener("mouseenter", () => {
      clearTimeout(cycleTimer);
      if (isMorphing) return;
      const lines = padLines(fontArts[currentTextIndex]);
      const width = lines[0]?.length || 0;
      scrambleInterval = setInterval(() => {
        el.textContent = lines
          .map((line) =>
            Array.from(line)
              .map((ch) =>
                ch === " "
                  ? " "
                  : GLITCH_CHARS[Math.floor(Math.random() * GLITCH_CHARS.length)]
              )
              .join("")
          )
          .join("\n");
      }, FRAME_RATE);
    });

    el.addEventListener("mouseleave", () => {
      clearInterval(scrambleInterval);
      scrambleInterval = null;
      if (!isMorphing) {
        el.textContent = fontArts[currentTextIndex];
        scheduleCycle();
      }
    });

    scheduleCycle();
  });
</script>
